---
layout: post
title: CVE-2025-23266 â€“ part 2
tags: writeups nvidia, containers, security
comments: true
---

# Introduction

In my [previous post](/posts/nvidia-container-escape-cve-2025-23266) about CVE-2025-23266 I covered:

- Dynamic linker behavior (to explain how `LD_PRELOAD` works)  
- Alternate runtimes (to explain what the NVIDIA Container Toolkit is)  
- CUDA forward compatibility (why the toolkit uses a `createContainer` hook)  
- Container Device Interface (what `createContainer` hooks are)  

But one important detail was missing. From the original [Wiz write-up](https://www.wiz.io/blog/nvidia-ai-vulnerability-cve-2025-23266-nvidiascape):

> While prestart hooks run in a clean, isolated context, createContainer hooks have a critical property: they inherit environment variables from the container image unless explicitly configured not to.

That inheritance is the crux of the vulnerability. As I dug into this, I found something surprising:

# This was already fixed in runc

My first attempt was to reproduce the issue by hand, using runc with a minimal OCI spec.

```bash
# Create bundle directory structure
mkdir /tmp/mycontainer
cd /tmp/mycontainer
mkdir rootfs

# Download and extract Alpine Linux
wget https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/x86_64/alpine-minirootfs-3.19.1-x86_64.tar.gz
tar -C rootfs -xzf alpine-minirootfs-3.19.1-x86_64.tar.gz

# Generate OCI spec
runc spec
```

Then I modified `config.json` to add a `createContainer` hook:

```json
"hooks": {
  "createContainer": [
    {
      "path": "/tmp/mycontainer/dumpenv",
      "args": ["none"]
    }
  ]
}
```

and set environment variables:

```json
"env": [
  "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
  "TERM=xterm",
  "FOO=bar"
]
```

The `dumpenv` program simply wrote all its environment variables to a file:

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[], char *envp[]) {
    FILE *fp = fopen("/tmp/envdump.txt", "w");
    if (!fp) return 1;

    for (char **env = envp; *env; env++) {
        fprintf(fp, "%s\n", *env);
    }
    fclose(fp);
    return 0;
}
```

Both this approach and a variant that used `sleep(60)` (and then inspecting `/proc/<pid>/environ`) showed the expected result: `FOO=bar` was visible in the hookâ€™s environment.

But when I built the latest runc from [GitHub](https://github.com/opencontainers/runc), the bug was gone. On my system, Ubuntu shipped runc **1.2.5**, which reproduced the issue. Current runc is **1.3.1**, where the issue no longer reproduces. After bisecting, I traced the fix to this commit:

ðŸ‘‰ [06f1e0765576dcf6d8c2ef5e56d309618310992c](https://github.com/opencontainers/runc/commit/06f1e0765576dcf6d8c2ef5e56d309618310992c)

# The `populateProcessEnvironment` function

That commit modified how runc sets environment variables. The key is `populateProcessEnvironment`, which calls `os.Setenv` for each variable in `config.Env`. While it didnâ€™t set the hookâ€™s env directly, it updated the parent processâ€™s environment. Because Goâ€™s `exec.Cmd` defaults to inheriting the parent environment, the hook ended up with container-supplied variables, including `LD_PRELOAD`.

To test this theory, I created a hook that just slept for 120 seconds:

```c
#include <stdio.h>
#include <unistd.h>

int main(void) {
    printf("Sleeping...\n");
    sleep(120);
    return 0;
}
```

Then I inspected its parent process with `ps axjf` and `/proc/<pid>/environ`. Instead of `FOO=BAR`, I only saw `_LIBCONTAINER_*` variables. 

Eventually, I realized I could trace all `setenv` calls directly:

```bash
sudo ltrace -e setenv -f runc create mycontainer
```

The `-f` flag is important, since it tells setenv follows child processes:

```
[pid 254818] runc->setenv("TERM", "xterm", 1) = 0
[pid 254818] runc->setenv("FOO", "bar", 1) = 0
```

# Detour: environment variables on Linux

On Linux, an environment variable can appear in two ways:

- At **exec time**, passed in the `envp` array of an `execve()` call  
- At **run time**, changed by the C library function `setenv()`  

`/proc/<pid>/environ` shows the current contents of the processâ€™s `environ` block in memory. Programs that call `setenv()` (or Goâ€™s `os.Setenv`) will update it. But beware: shells like Bash keep their own variable tables. When you `export FOO=BAR` interactively, the shell marks it for children but may not update its own `environ`. As a result, `/proc/<shell-pid>/environ` might not show your new variable, even though child processes inherit it.

# The runc init stage

Hereâ€™s what happens during `runc create`:

- `runc init` starts
  - It enters namespaces (via `nsenter`)  
  - Initializes the container (`startInitialization`), which:
    - Runs the `createContainer` hook  
    - Calls `pivot_root`  
    - Finally `execve()`s the container process  

From inside the PID namespace, `runc init` is PID 1, and all processes (including hooks) are its children.

Before commit [06f1e07](https://github.com/opencontainers/runc/commit/06f1e0765576dcf6d8c2ef5e56d309618310992c), the sequence was:

- `runc init` starts  
- `containerInit` calls `populateProcessEnvironment`, which does `setenv` for each entry in `config.Env`  
- Hooks started with `exec.Cmd` inherited those values  

# exec.Cmd behavior

Goâ€™s [`exec.Cmd`](https://pkg.go.dev/os/exec) works like this:

```go
// Env specifies the environment of the process.
// If Env is nil, the new process uses the current process's environment.
```

That default is what allowed the bug: if `runc init` had `LD_PRELOAD` in its environment, every hook process would inherit it unless explicitly sanitized.

# Putting it all together

- An attacker builds an image with `LD_PRELOAD=./poc.so`.  

  ```dockerfile
  FROM busybox
  ENV LD_PRELOAD=./poc.so
  ADD poc.so /
  ```

- On runc â‰¤1.2.5:
  - `runc init` calls `populateProcessEnvironment`, which sets `LD_PRELOAD` in its own environment.  
  - Hooks started with no explicit `Env` inherit that.  
  - The malicious `poc.so` is loaded before the hookâ€™s own code runs.  

This does **not** affect `runc init` itself, since `LD_PRELOAD` only applies at exec time, not to an already-running binary. But it does affect the hook subprocesses.

# Conclusion

Older runc versions (â‰¤1.2.5) unintentionally allowed container-supplied environment variables to leak into host-side hooks, creating a neat `LD_PRELOAD` injection path. Commit [06f1e07](https://github.com/opencontainers/runc/commit/06f1e0765576dcf6d8c2ef5e56d309618310992c) fixed this by sanitizing the environment before running hooks.

**Takeaway:** If you rely on `createContainer` hooks, upgrade your runc. Otherwise, container images could trick your hook into loading arbitrary libraries.