---
layout: post
title: CVE 2025-23266 -  part 2
tags: writeups nvidia, containers, security
comments: true
---

# Introduction

On my previous post about CVE 2025-23266 I wrote about the following aspects of this vulnerabilty:

- Dynamic linker behavior (necessary to understand how does `LD_PRELOAD` works)
- Alternate runtimes (neccessary to understand what Nvidia Container Toolkit is, after all)
- CUDA Forward Compatibility (necessary to understand why does the NVidia Container toolkit has a `createContainer` hook)
- Container device interface (what are `createContainer` hooks)

However, one thing that was missing from my initial writeup was this (from the original [Wiz writeup](https://www.wiz.io/blog/nvidia-ai-vulnerability-cve-2025-23266-nvidiascape)):

> While prestart hooks run in a clean, isolated context, createContainer hooks have a critical property: they inherit environment variables from the container image unless explicitly configured not to.

As I set out to investigate this issue, I ended up discovering one thing:

# This was fixed on latest runC

That was a surprise for me as well. First I tried to reproduce this issue manually by using runc with a handcrafted spec:

```bash
# Create bundle directory structure  
mkdir /tmp/mycontainer
cd /tmp/mycontainer
mkdir rootfs

# Download and extract Alpine Linux directly
wget https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/x86_64/alpine-minirootfs-3.19.1-x86_64.tar.gz
tar -C rootfs -xzf alpine-minirootfs-3.19.1-x86_64.tar.gz

# Alternative: Download BusyBox static binary
# mkdir -p rootfs/{bin,usr/bin,sbin,usr/sbin,etc,proc,sys,dev}
# wget -O rootfs/bin/busybox https://busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox
# chmod +x rootfs/bin/busybox
# cd rootfs && for cmd in $(./bin/busybox --list); do ln -s /bin/busybox bin/$cmd 2>/dev/null || true; done && cd ..

# Generate OCI spec with all namespaces
runc spec
```

Then I changed the config.json file to trigger a hook like this:

```

 "hooks": {
    "createContainer": [
      {
        "path": "/tmp/mycontainer/dumpenv",
        "args": [
          "none"
        ]
      }
    ]

```

and set the env vars with:

```
 "env": [
      "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
      "TERM=xterm",
      "FOO=bar"
    ],
```

The dumpenv application just list all environment variables and dump them in a file:

```
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[], char *envp[]) {
    FILE *fp = fopen("/tmp/envdump.txt", "w");
    if (fp == NULL) {
        perror("fopen");
        return 1;
    }

    for (char **env = envp; *env != NULL; env++) {
        fprintf(fp, "%s\n", *env);
    }

    fclose(fp);
    return 0;
}

```

You can also create a program that runs "sleep(60)" and check for the environment variables with `cat /proc/<pid>/environ`

Either approaches yielded the resulted I was expection, which is returning the `FOO=bar` environment variable.

My next step was downloading the latest version from https://github.com/opencontainers/runc, build it myself and add a few logs.

However, that quickly turned into a blunder. **The issue was not reproducible on the latest version.**

# Searching for the actual version

it took me 20 mins to bisect all versions, but I finally narrowed it down to this commit:

[https://github.com/opencontainers/runc/commit/06f1e0765576dcf6d8c2ef5e56d309618310992c](https://github.com/opencontainers/runc/commit/06f1e0765576dcf6d8c2ef5e56d309618310992c)


I'll be updating this post once I figure out why does that fixes this issue.